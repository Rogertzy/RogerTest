const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const { Epc, Shelf, ReturnBox } = require('./epcSchema');

dotenv.config();

const app = express();
app.use(express.json());

// Connect to MongoDB
mongoose.connect(process.env.MONGODB_URI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => console.error('MongoDB connection error:', err));

// GET /api/rfid-readers - Fetch all shelves and return boxes with their EPCs
app.get('/api/rfid-readers', async (req, res) => {
  try {
    const shelves = await Shelf.find();
    const returnBoxes = await ReturnBox.find();
    const epcs = await Epc.find();

    const shelfData = await Promise.all(shelves.map(async shelf => {
      const shelfEpcs = epcs.filter(epc => epc.readerIp === shelf.readerIp);
      return {
        name: shelf.name,
        readerIp: shelf.readerIp,
        status: shelfEpcs.length > 0 || shelf.connected ? 'active' : 'inactive',
        epcs: shelfEpcs.map(epc => ({
          epc: epc.epc,
          title: epc.title,
          author: epc.author,
          status: epc.status
        }))
      };
    }));

    const returnBoxData = await Promise.all(returnBoxes.map(async box => {
      const boxEpcs = epcs.filter(epc => epc.readerIp === box.readerIp);
      return {
        name: box.name,
        readerIp: box.readerIp,
        status: boxEpcs.length > 0 || box.connected ? 'active' : 'inactive',
        epcs: boxEpcs.map(epc => ({
          epc: epc.epc,
          title: epc.title,
          author: epc.author,
          status: epc.status
        }))
      };
    }));

    res.json({ shelves: shelfData, returnBoxes: returnBoxData });
  } catch (error) {
    console.error('Error fetching RFID readers:', error);
    res.status(500).json({ error: error.message });
  }
});

// POST /api/rfid-update - Update EPC status based on local client data
app.post('/api/rfid-update', async (req, res) => {
  const { readerIp, epc, type, detected } = req.body;

  try {
    if (type === 'shelf' || type === 'return_box') {
      const Model = type === 'shelf' ? Shelf : ReturnBox;
      const reader = await Model.findOne({ readerIp });
      if (!reader) return res.status(404).json({ error: `${type} not found` });

      if (detected) {
        let epcDoc = await Epc.findOne({ epc });
        if (!epcDoc) {
          epcDoc = new Epc({
            epc,
            title: 'Unknown Title',
            author: ['Unknown Author'],
            status: type === 'shelf' ? 'in library' : 'in return box',
            readerIp,
          });
          await epcDoc.save();
        } else if (epcDoc.readerIp !== readerIp) {
          epcDoc.readerIp = readerIp;
          epcDoc.status = type === 'shelf' ? 'in library' : 'in return box';
          epcDoc.logs.push({ message: `Moved to ${readerIp}`, timestamp: new Date() });
          await epcDoc.save();
        }
      } else {
        const epcDoc = await Epc.findOne({ epc, readerIp });
        if (epcDoc) {
          epcDoc.readerIp = null;
          epcDoc.status = 'borrowed';
          epcDoc.logs.push({ message: `Removed from ${readerIp}`, timestamp: new Date() });
          await epcDoc.save();
        }
      }
      res.sendStatus(200);
    } else {
      res.status(400).json({ error: 'Invalid type' });
    }
  } catch (error) {
    console.error('Error updating EPC:', error);
    res.status(500).json({ error: error.message });
  }
});

// POST /api/connection-status - Update reader connection status
app.post('/api/connection-status', async (req, res) => {
  const { readerIp, connected } = req.body;

  try {
    let reader = await Shelf.findOne({ readerIp }) || await ReturnBox.findOne({ readerIp });
    if (reader) {
      reader.connected = connected;
      await reader.save();
    }
    res.sendStatus(200);
  } catch (error) {
    console.error('Error updating connection status:', error);
    res.status(500).json({ error: error.message });
  }
});

// POST /api/shelves - Add a new shelf
app.post('/api/shelves', async (req, res) => {
  const { name, readerIp } = req.body;

  try {
    const existingShelf = await Shelf.findOne({ readerIp });
    if (existingShelf) return res.status(400).json({ error: 'Shelf already exists' });

    const shelf = new Shelf({ name, readerIp, connected: false });
    await shelf.save();
    res.status(201).json(shelf);
  } catch (error) {
    console.error('Error adding shelf:', error);
    res.status(500).json({ error: error.message });
  }
});

// DELETE /api/shelves/:readerIp - Delete a shelf
app.delete('/api/shelves/:readerIp', async (req, res) => {
  const { readerIp } = req.params;

  try {
    const shelf = await Shelf.findOneAndDelete({ readerIp });
    if (!shelf) return res.status(404).json({ error: 'Shelf not found' });

    // Optionally clear EPCs associated with this shelf
    await Epc.updateMany({ readerIp }, { $set: { readerIp: null, status: 'borrowed' } });
    res.sendStatus(204);
  } catch (error) {
    console.error('Error deleting shelf:', error);
    res.status(500).json({ error: error.message });
  }
});

// POST /api/return-boxes - Add a new return box
app.post('/api/return-boxes', async (req, res) => {
  const { name, readerIp } = req.body;

  try {
    const existingBox = await ReturnBox.findOne({ readerIp });
    if (existingBox) return res.status(400).json({ error: 'Return box already exists' });

    const box = new ReturnBox({ name, readerIp, connected: false });
    await box.save();
    res.status(201).json(box);
  } catch (error) {
    console.error('Error adding return box:', error);
    res.status(500).json({ error: error.message });
  }
});

// DELETE /api/return-boxes/:readerIp - Delete a return box
app.delete('/api/return-boxes/:readerIp', async (req, res) => {
  const { readerIp } = req.params;

  try {
    const box = await ReturnBox.findOneAndDelete({ readerIp });
    if (!box) return res.status(404).json({ error: 'Return box not found' });

    // Optionally clear EPCs associated with this return box
    await Epc.updateMany({ readerIp }, { $set: { readerIp: null, status: 'borrowed' } });
    res.sendStatus(204);
  } catch (error) {
    console.error('Error deleting return box:', error);
    res.status(500).json({ error: error.message });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});